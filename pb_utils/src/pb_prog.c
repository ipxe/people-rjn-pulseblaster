/* This is pb_prog.c  It programs the pulseblaster with the contents of a program-file supplied. If the program-file is a .vliw file, it will
 * Parse it and then program the device. If the Program file is a .bin file, it will just write it to the device.
 * If saving (rather than programming) the .bin file is desired, use pb_asm (which is a special case of this file)
 * Invoke it as pb_prog FILENAME.vliw   or pb_prog FILENAME.bin.
 * Most of the important, shared stuff is in pb_functions.c */

#include "pb_functions.c"

void printhelp(){
	fprintf(stderr, "pb_prog programs the PulseBlaster from a VLIW or binary file.\n"
		"VLIW (.vliw) files are parsed, checked and compensated before programming the device.\n"
		"Alternatively, a binary (.bin) file previously generated by pb_asm may be used.\n"
		"If the PulseBlaster is running, pb_prog will implicitly stop it first.\n"
		"After programming, the PulseBlaster is left in the STOPPED, NOT_ARMED state.\n"
		"Programming doesn't change the state of the outputs: Use pb_init, then pb_prog.\n\n"
		"USAGE:    pb_prog FILENAME.vliw      (human-readable VLIW format, with validation)\n"
		"          pb_prog FILENAME.bin       (pre-compiled binary 'blob', minimal validation)\n"
		"          pb_prog -                  (binary format, from stdin)\n"
		"          pb asm - - | pb_prog -     (vliw format, from stdin)\n");
}

int main(int argc, char *argv[]){

	unsigned int line_num;		/* Line number in source file. one-based, for human-readability */
	unsigned int prog_lines = 0;	/* Lines of actal code programmed */
	unsigned char flags[3];
	unsigned int is_vliw = 0;	/* File extension => type */
	unsigned int is_bin = 0;
	int ret = 0;			/* General retval */
	int fatal_error = 0;
	int error_exit = PB_ERROR_GENERIC;
	char buffer[VLIWLINE_MAXLEN];   /* 1024 */
	FILE *source_fh;
	struct stat stat_p;		/* pointer to stat structure */

	if (argc != 2){
		fprintf(stderr,"Error, wrong number of arguments. Use -h for help.\n");
		exit (PB_ERROR_WRONGARGS);
	}
	if ((!strcmp (argv[1], "-h")) || (!strcmp (argv[1], "--help"))){
		printhelp();
		exit (PB_ERROR_WRONGARGS);
	}

	if (!strcmp (argv[1], "-" ) ){	/* Use stdin? */
		is_bin = 1;
		source_fh = stdin;

	}else{				/* Normal file. */

		if (!strcmp ( (argv[1] + strlen(argv[1]) - 5), ".vliw") ){	/* Check that the file extension is ".vliw" (or ".bin"). Very very useful sanity check to enforce */
			is_vliw = 1;
		}else if  (!strcmp ( (argv[1] + strlen(argv[1]) - 4), ".bin") ){
			is_bin = 1;
		}else{
			fprintf(stderr,"Error, program file %s is neither a .vliw, nor a .bin file. \n", argv[1]);
			exit (PB_ERROR_WRONGARGS);
		}

		if ((source_fh = fopen(argv[1],"r")) == NULL){			/* Check that the file exists and is readable; Open it. */
			fprintf(stderr,"Could not open program-file %s.\n",argv[1]);
			exit (PB_ERROR_WRONGARGS);
		}

		if (stat (argv[1], &stat_p) == -1){  				/* Get stats for file and place them in the structure */
			fprintf(stderr,"Error occurred attempting to stat %s\n", argv[1]);  /* This error shouldn't happen - we already managed to open the file! */
			exit(PB_ERROR_GENERIC);
		}

		if (stat_p.st_size == 0){	/* Error, if the .vliw file is empty.  Empty .vliw files get created if the .pbsrc file contains a fatal error */
			fprintf(stderr,"Error: file %s is empty! This usually occurs if pb_parse found a fatal error in the .pbsrc file.\n", argv[1]);
			exit (PB_ERROR_EMPTYVLIWFILE);
		}
	}

	/* Open pulseblaster; check device is present */
	pb_fopen();


	if (is_vliw == 1){	/* VLIW file. Read it, parse it, and program it. */

		/* Iterate over the file, one line at a time. Note: don't use feof(), or the last line will be duplicated - ugh! */
		line_num = 1; 		/* Line is one-based */

		while (fgets(buffer, VLIWLINE_MAXLEN, source_fh) != NULL){

			/* Parse a line of program source code. Parse it into VLIW tokens, compensate, and put the result into vliw_buf[]; then return 0 */
			/* If the line is invalid, exit with error. If the line is BLANK or a COMMENT, return -1; DO NOT then call pb_write_program(), as you would duplicate the last instruction! */
			ret = pb_parse_sourceline (buffer, line_num);
			if (ret > 0){ 			/* Error encountered during parsing. Clean up and exit */
				error_exit = ret;
				fatal_error = 1;
				break;

			}else if (ret == -1){
				continue;		/* Don't double-program the previous line. */
			}else{
				prog_lines++;
				pb_write_program();	/* Write the vliw buffer to the pulseblaster device. */
			}
			line_num++;
		}

		if ((!fatal_error) && (check_loop_depth() != 0)){	/* Last check on loop depth */
			fatal_error = 1;
		}

	}else if (is_bin){	/* Bin file. Just blat it to the device. The only check we can do is that there is an exact multiple of 10 bytes */

		/* Read bytes from the stream, in groups of 10 */
		while ((ret = fread(vliw_buf, sizeof(char), sizeof(vliw_buf), source_fh)) != 0){

			if (ret != PB_BPW_VLIW){ 	/* We read > 0 but not 10 bytes. Suggests a partial VLIW instruction */
				fprintf(stderr, "Error: executable file %s is %d bytes long, but should be a multple of %d.\n", argv[1], (int)stat_p.st_size, PB_BPW_VLIW);
				if (source_fh == stdin){  /* Hint...,if we sent a vliw file to stdin (but this isn't reliable: 1 time in 10, can still accidentally program a vliw as if it were a bin). */
					fprintf(stderr, "Hint: when input file is stdin, filetype must be .bin, nor .vliw. Try piping though 'pb_asm - -'.\n");
				}
				fatal_error = 1;	/* Fatal error - ensure the PB is zeroed below */
				error_exit = PB_ERROR_BADVLIWFILE;
				break;
			}else{
				prog_lines++;
				pb_write_program();
			}
		}
	}

	/* close data-file descriptor */
	fclose(source_fh);

	/* If we don't get here, we already exited with error msg and errorcode */

	if ((prog_lines == 0) && (!fatal_error)){
		fprintf(stderr, "Error: program file %s contains no instructions.\n", argv[1]);
		fatal_error = 1;
		error_exit = PB_ERROR_BADVLIWFILE;
	}

	if (fatal_error){
		/* Something went wrong. We might have a partial program loaded. Or worse, if we programmed exactly nothing, we actually left the old program present! */
		/* On the "least-surprise principle", write in a program to zero the outputs */
		flags[2] = flags[1] = flags[0] = 0;
		pb_init(flags);

		fprintf(stderr, "Error in program %s.\nPulseBlaster has been zeroed, to prevent accidentally re-running the previous program.\n", argv[1]);
		exit (error_exit);
	}

	fprintf(stderr, "PulseBlaster has been programmed with %d instructions from file %s. Not armed nor started; run: pb_start / pb_arm + HW_Trigger.\n", prog_lines, argv[1]);

        /* Close the device */
        pb_fclose();

	return PB_EXIT_OK;	/* i.e. zero */
}
